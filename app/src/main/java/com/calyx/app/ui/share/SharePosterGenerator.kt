package com.calyx.app.ui.share

import android.content.Context
import android.content.Intent
import android.graphics.Bitmap
import android.graphics.Canvas
import android.graphics.Color
import android.graphics.LinearGradient
import android.graphics.Paint
import android.graphics.RectF
import android.graphics.Shader
import android.graphics.Typeface
import androidx.core.content.FileProvider
import androidx.core.content.res.ResourcesCompat
import com.calyx.app.R
import com.calyx.app.data.models.CallerStats
import com.calyx.app.data.models.RankingCategory
import com.calyx.app.utils.DurationFormatter
import com.calyx.app.utils.PhoneNumberUtils
import android.graphics.PorterDuff
import android.graphics.PorterDuffXfermode
import android.graphics.DashPathEffect
import android.graphics.Path
import android.graphics.Rect
import android.util.Log
import java.io.File
import java.io.FileOutputStream
import java.io.IOException

/**
 * Share Poster Generator - Creates a 1080x1920 (9:16) image for social sharing.
 * 
 * Design:
 * - Background: Dark nature/forest theme
 * - Header: "My Circle" + App Logo
 * - Center: Top 3 Podium (large)
 * - Lower: Two-column grid for ranks 4-10
 * - Footer: "Generated by Calyz"
 */
object SharePosterGenerator {
    
    private const val POSTER_WIDTH = 1080
    private const val POSTER_HEIGHT = 1920

    // Pre-created Typefaces to avoid reloading
    private var boldTypeface: Typeface? = null
    private var regularTypeface: Typeface? = null
    
    /**
     * Prepare fonts for rendering.
     */
    private fun initFonts(context: Context) {
        if (boldTypeface == null) {
            boldTypeface = ResourcesCompat.getFont(context, R.font.lufga_bold)
        }
        if (regularTypeface == null) {
            regularTypeface = ResourcesCompat.getFont(context, R.font.lufga_regular)
        }
    }
    /**
     * Generate and share a poster with the top 10 contacts.
     * Uses Canvas-based rendering to avoid Compose window attachment issues.
     */
    fun shareTopContacts(
        context: Context,
        topContacts: List<CallerStats>,
        category: RankingCategory
    ) {
        try {
            initFonts(context)
            // Create bitmap using Canvas-based rendering
            val bitmap = createPosterBitmap(context, topContacts, category)
            
            if (bitmap == null) {
                shareAsText(context, topContacts.take(10), category)
                return
            }

            // Save to cache and share
            val file = saveBitmapToCache(context, bitmap)
            shareBitmap(context, file)
        } catch (e: Exception) {
            Log.e("CalyzShare", "Error generating share poster", e)
            // Fallback: Share as text if bitmap generation fails
            shareAsText(context, topContacts.take(10), category)
        }
    }
    
    /**
     * Create the poster bitmap using Canvas and Paint APIs.
     */
    private fun createPosterBitmap(
        context: Context,
        topContacts: List<CallerStats>,
        category: RankingCategory
    ): Bitmap? {
        val options = android.graphics.BitmapFactory.Options().apply {
            inMutable = true
            inScaled = false
        }
        
        val template = try {
            android.graphics.BitmapFactory.decodeResource(
                context.resources, 
                com.calyx.app.R.drawable.share_template,
                options
            )
        } catch (e: Exception) {
            null
        } ?: return null
        
        val bitmap = template.copy(Bitmap.Config.ARGB_8888, true)
        val canvas = Canvas(bitmap)
        
        // Use quality paints
        val mainPaint = Paint().apply {
            isAntiAlias = true
            isFilterBitmap = true
            isDither = true
        }

        // 1. Overlay User Handle (Premium Positioning)
        val prefs = context.getSharedPreferences("calyz_prefs", Context.MODE_PRIVATE)
        val userName = prefs.getString("user_name", "USER")?.uppercase() ?: "USER"
        
        val usernamePaint = Paint().apply {
            color = 0xAAFFFFFF.toInt() // 66% White
            textSize = 36f
            typeface = regularTypeface ?: Typeface.SANS_SERIF
            textAlign = Paint.Align.CENTER
            isAntiAlias = true
            letterSpacing = 0.25f
        }
        canvas.drawText("@$userName", POSTER_WIDTH / 2f, 178f, usernamePaint)
        
        // 2. Top 3 Podium Dynamic Data
        if (topContacts.isNotEmpty()) {
            drawPodium(context, canvas, topContacts.take(3), category)
        }
        
        // 3. Remaining List (4-10)
        val remaining = topContacts.drop(3).take(7)
        if (remaining.isNotEmpty()) {
            drawSimpleList(canvas, remaining, category)
        }
        
        return bitmap
    }
    
    private fun drawPodium(context: Context, canvas: Canvas, top3: List<CallerStats>, category: RankingCategory) {
        // Positions refined to match share_template.png
        
        // Helper to get formatted score
        fun getScore(c: CallerStats): String = when (category) {
            RankingCategory.MOST_CALLED -> "${c.totalCalls} Calls"
            RankingCategory.MOST_TALKED -> DurationFormatter.formatShort(c.totalDuration)
        }
        
        // Draw #2 (Left Arch)
        if (top3.size >= 2) {
            drawArchItem(
                context, canvas, top3[1], 
                cx = 230f, 
                cy = 585f, 
                width = 200f, 
                height = 360f,
                score = getScore(top3[1])
            )
        }
        
        // Draw #3 (Right Arch)
        if (top3.size >= 3) {
            drawArchItem(
                context, canvas, top3[2], 
                cx = 850f, 
                cy = 585f, 
                width = 200f, 
                height = 360f,
                score = getScore(top3[2])
            )
        }
        
        // Draw #1 (Center Sunburst)
        if (top3.isNotEmpty()) {
            drawStarburstItem(
                context, canvas, top3[0], 
                cx = POSTER_WIDTH / 2f, 
                cy = 535f, 
                radius = 160f,
                score = getScore(top3[0])
            )
        }
    }
    
    // Draw #Rank with Starburst effect
    private fun drawStarburstItem(
        context: Context, 
        canvas: Canvas, 
        caller: CallerStats, 
        cx: Float, 
        cy: Float, 
        radius: Float,
        score: String
    ) {
        // 1. Draw Photo (Circular Clip)
        val photoBitmap = loadContactPhoto(context, caller.profilePhotoUri, (radius * 2).toInt())
        
        canvas.save()
        val photoPath = Path().apply {
            addCircle(cx, cy, radius, Path.Direction.CW)
        }
        canvas.clipPath(photoPath)
        
        if (photoBitmap != null) {
            val srcRect = Rect(0, 0, photoBitmap.width, photoBitmap.height)
            val dstRect = RectF(cx - radius, cy - radius, cx + radius, cy + radius)
            canvas.drawBitmap(photoBitmap, srcRect, dstRect, Paint(Paint.FILTER_BITMAP_FLAG or Paint.ANTI_ALIAS_FLAG))
        } else {
            canvas.drawColor(0xFF81C784.toInt()) // Fresh green fallback
        }
        canvas.restore()

        // 2. High-Quality Border
        val borderPaint = Paint().apply {
            color = Color.WHITE
            style = Paint.Style.STROKE
            strokeWidth = 6f
            isAntiAlias = true
        }
        canvas.drawCircle(cx, cy, radius, borderPaint)
        
        // 3. Text Below (Adjusted for better fit)
        val scoreY = cy + radius + 120f
        val nameY = scoreY + 45f
        drawTextInfo(canvas, score, caller.displayName, cx, scoreY, nameY, isCenter = true)
    }

    // Draw #2 and #3 with Arch Shape
    private fun drawArchItem(
        context: Context,
        canvas: Canvas,
        caller: CallerStats,
        cx: Float,
        cy: Float,
        width: Float,
        height: Float,
        score: String
    ) {
        val halfW = width / 2
        val halfH = height / 2
        
        // 1. Build Arch Path
        val path = Path()
        val rect = RectF(cx - halfW, cy - halfH, cx + halfW, cy + halfH)
        val cornerRadius = width / 2
        path.addRoundRect(rect, floatArrayOf(
            cornerRadius, cornerRadius,
            cornerRadius, cornerRadius,
            0f, 0f,
            0f, 0f
        ), Path.Direction.CW)

        // 2. Photo Content
        val photoBitmap = loadContactPhoto(context, caller.profilePhotoUri, width.toInt())
        
        canvas.save()
        canvas.clipPath(path)
        
        if (photoBitmap != null) {
            val scale = maxOf(width / photoBitmap.width, height / photoBitmap.height)
            val scaledW = photoBitmap.width * scale
            val scaledH = photoBitmap.height * scale
            val dx = cx - scaledW / 2
            val dy = cy - scaledH / 2
            val dstRect = RectF(dx, dy, dx + scaledW, dy + scaledH)
            
            canvas.drawBitmap(photoBitmap, null, dstRect, Paint(Paint.FILTER_BITMAP_FLAG or Paint.ANTI_ALIAS_FLAG))
        } else {
             canvas.drawColor(0xFF4A6B5C.toInt()) // Mossy fallback
        }
        canvas.restore()

        // 3. Subtle Border for Depth
        val borderPaint = Paint().apply {
            color = 0x44FFFFFF.toInt()
            style = Paint.Style.STROKE
            strokeWidth = 3f
            isAntiAlias = true
        }
        canvas.drawPath(path, borderPaint)
        
        // 4. Text Below (Adjusted for better fit)
        val scoreY = cy + halfH + 45f
        val nameY = scoreY + 40f
        drawTextInfo(canvas, score, caller.displayName, cx, scoreY, nameY, isCenter = false)
    }
    
    private fun drawTextInfo(canvas: Canvas, score: String, name: String, x: Float, scoreY: Float, nameY: Float, isCenter: Boolean) {
        // Score Paint - Bold & White
        val scorePaint = Paint().apply {
            color = Color.WHITE
            textSize = if (isCenter) 48f else 38f
            typeface = boldTypeface ?: Typeface.DEFAULT_BOLD
            textAlign = Paint.Align.CENTER
            isAntiAlias = true
            // Add shadow for better legibility against any background
            setShadowLayer(5f, 0f, 3f, 0xAA000000.toInt())
        }
        canvas.drawText(score, x, scoreY, scorePaint)
        
        // Name Paint - Muted Mint White
        val namePaint = Paint().apply {
            color = 0xEEF0FFF0.toInt() // Almost solid minty white
            textSize = if (isCenter) 32f else 26f
            typeface = regularTypeface ?: Typeface.SANS_SERIF
            textAlign = Paint.Align.CENTER
            isAntiAlias = true
            setShadowLayer(3f, 0f, 2f, 0x88000000.toInt())
        }
        val safeName = PhoneNumberUtils.getDisplayName(name, "").take(16)
        canvas.drawText(safeName, x, nameY, namePaint)
    }
    
    private fun drawSimpleList(canvas: Canvas, remaining: List<CallerStats>, category: RankingCategory) {
        val startY = 1118f
        val lineHeight = 92f
        
        // Premium Text Paints
        val rankNamePaint = Paint().apply {
            color = Color.WHITE
            textSize = 34f
            typeface = regularTypeface ?: Typeface.SANS_SERIF
            textAlign = Paint.Align.LEFT
            isAntiAlias = true
            setShadowLayer(2f, 0f, 1f, 0x88000000.toInt())
        }
        
        val scorePaint = Paint().apply {
            color = 0xAAFFFFFF.toInt() // Slightly muted for secondary info
            textSize = 32f
            typeface = regularTypeface ?: Typeface.SANS_SERIF
            textAlign = Paint.Align.RIGHT
            isAntiAlias = true
        }
        
        val leftAnchor = 130f
        val rightAnchor = POSTER_WIDTH - 130f
        
        remaining.forEachIndexed { index, caller ->
            val y = startY + (index * lineHeight)
            val rank = 4 + index
            
            // "4. Name"
            val dispName = PhoneNumberUtils.getDisplayName(caller.displayName, caller.phoneNumber)
            val safeName = if (dispName.length > 20) dispName.take(18) + ".." else dispName
            canvas.drawText("$rank. $safeName", leftAnchor, y, rankNamePaint)
            
            // "[x] calls"
            val scoreText = when (category) {
                RankingCategory.MOST_CALLED -> "${caller.totalCalls} calls"
                RankingCategory.MOST_TALKED -> DurationFormatter.formatShort(caller.totalDuration).lowercase()
            }
            canvas.drawText(scoreText, rightAnchor, y, scorePaint)
        }
    }
    
    private fun loadContactPhoto(context: Context, uriString: String?, reqSize: Int): Bitmap? {
        if (uriString.isNullOrEmpty()) return null
        
        return try {
            val uri = android.net.Uri.parse(uriString)
            context.contentResolver.openInputStream(uri)?.use { stream ->
                // Decode metadata only to find dimensions
                val options = android.graphics.BitmapFactory.Options().apply {
                    inJustDecodeBounds = true
                }
                android.graphics.BitmapFactory.decodeStream(stream, null, options)
                
                // Reset stream for actual decode
                context.contentResolver.openInputStream(uri)?.use { newStream ->
                    val sampleOptions = android.graphics.BitmapFactory.Options().apply {
                        inSampleSize = calculateInSampleSize(options, reqSize, reqSize)
                    }
                    val decoded = android.graphics.BitmapFactory.decodeStream(newStream, null, sampleOptions)
                    
                    // Final crop/scale to exactly reqSize if needed
                    if (decoded != null) {
                        return zoomAndCropCenter(decoded, reqSize, reqSize)
                    }
                }
            }
            null
        } catch (e: Exception) {
            null
        }
    }

    private fun calculateInSampleSize(options: android.graphics.BitmapFactory.Options, reqWidth: Int, reqHeight: Int): Int {
        val (height: Int, width: Int) = options.outHeight to options.outWidth
        var inSampleSize = 1
        if (height > reqHeight || width > reqWidth) {
            val halfHeight: Int = height / 2
            val halfWidth: Int = width / 2
            while (halfHeight / inSampleSize >= reqHeight && halfWidth / inSampleSize >= reqWidth) {
                inSampleSize *= 2
            }
        }
        return inSampleSize
    }

    private fun zoomAndCropCenter(source: Bitmap, reqWidth: Int, reqHeight: Int): Bitmap {
        val sourceWidth = source.width
        val sourceHeight = source.height
        
        val xScale = reqWidth.toFloat() / sourceWidth
        val yScale = reqHeight.toFloat() / sourceHeight
        val scale = maxOf(xScale, yScale)
        
        val scaledWidth = scale * sourceWidth
        val scaledHeight = scale * sourceHeight
        
        val left = (reqWidth - scaledWidth) / 2
        val top = (reqHeight - scaledHeight) / 2
        
        val targetRect = RectF(left, top, left + scaledWidth, top + scaledHeight)
        
        val dest = Bitmap.createBitmap(reqWidth, reqHeight, source.config ?: Bitmap.Config.ARGB_8888)
        val canvas = Canvas(dest)
        canvas.drawBitmap(source, null, targetRect, Paint(Paint.FILTER_BITMAP_FLAG))
        
        return dest
    }
    
    // ... [Cache saving and Sharing methods remain unchanged] ...
    private fun saveBitmapToCache(context: Context, bitmap: Bitmap): File {
        val cacheDir = File(context.cacheDir, "share")
        cacheDir.mkdirs()
        val file = File(cacheDir, "my_circle_${System.currentTimeMillis()}.png")
        FileOutputStream(file).use { out ->
            bitmap.compress(Bitmap.CompressFormat.PNG, 100, out)
        }
        return file
    }
    
    private fun shareBitmap(context: Context, file: File) {
        val uri = FileProvider.getUriForFile(context, "${context.packageName}.fileprovider", file)
        val shareIntent = Intent(Intent.ACTION_SEND).apply {
            type = "image/png"
            putExtra(Intent.EXTRA_STREAM, uri)
            addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        }
        context.startActivity(Intent.createChooser(shareIntent, "Share your circle"))
    }
    
    private fun shareAsText(context: Context, topContacts: List<CallerStats>, category: RankingCategory) {
        // ... (Keep existing text fallback)
        val text = "Check out my Calyz stats!"
        val shareIntent = Intent(Intent.ACTION_SEND).apply {
            type = "text/plain"
            putExtra(Intent.EXTRA_TEXT, text)
            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        }
        context.startActivity(Intent.createChooser(shareIntent, "Share"))
    }
}
